<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XDC Peacock</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
        }
        h1 {
            color: #007bff;
        }
        h2 {
            color: #0056b3;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .output {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
            word-break: break-all;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 14px;
            color: #6c757d;
        }
        .note {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 15px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
</head>
<body>
    <header>
        <h1>XDC Peacock4: Post-Quantum Onchain Communication</h1>
        <p>Secure your messages on the XDC network with quantum-resistant encryption.</p>
    </header>

    <section id="keygen">
        <h2>1. Generate Post-Quantum Keypair</h2>
        <p>Click the button to generate a ML-KEM-768 keypair for encryption. Copy the keys securely.</p>
        <button onclick="generateKeypair()">Generate Keypair</button>
        <div id="publicKey" class="output"></div>
        <div id="privateKey" class="output"></div>
    </section>

    <section id="send">
        <h2>2. Encrypt and Send Message</h2>
        <p>Enter the recipient's details, encrypt the message using their public key, and send it as transaction data on XDC.</p>
        <label for="toAddr">To Address (xdc... or 0x..., optional):</label>
        <input id="toAddr" placeholder="e.g., xdc123... or 0x123... (leave blank for data-only to null address)">
        <p class="note">Leave blank to send to the null address (0x000...000) for pure data storage without transferring value to another account. This avoids errors when including data in transactions to regular accounts.</p>

        <label for="pubKey">Recipient's Public Key (hex):</label>
        <textarea id="pubKey" rows="4" placeholder="Paste public key here"></textarea>

        <label for="message">Message to Encrypt:</label>
        <textarea id="message" rows="4" placeholder="Enter your message"></textarea>

        <label for="amount">Amount of XDC to Send:</label>
        <input id="amount" type="number" value="0" step="any">

        <label for="rpc">RPC Endpoint:</label>
        <input id="rpc" value="https://rpc.ankr.com/xdc">

        <button onclick="connectWallet()">Connect MetaMask</button>
        <button onclick="sendMessage()">Send Message</button>
        <div id="txStatus" class="output"></div>
    </section>

    <section id="decrypt">
        <h2>3. Decrypt Message from Transaction</h2>
        <p>Enter the transaction hash and your private key to fetch and decrypt the message.</p>
        <label for="txHashInput">Transaction Hash:</label>
        <input id="txHashInput" placeholder="e.g., 0xabc...">

        <label for="privKey">Your Private Key (hex):</label>
        <textarea id="privKey" rows="4" placeholder="Paste private key here"></textarea>

        <label for="rpcDecrypt">RPC Endpoint:</label>
        <input id="rpcDecrypt" value="https://rpc.ankr.com/xdc">

        <button onclick="decryptMessage()">Decrypt Message</button>
        <div id="decryptedMessage" class="output"></div>
    </section>

    <footer>
        Built by s4njk4n | Hosted on GitHub Pages | <a href="https://xdcoutpost.xyz/peacock">Learn More</a>
    </footer>

    <script>
        let provider;
        const MLKEM_VARIANT = 'MlKem768';
        const CT_SIZE = 1088; // For ML-KEM-768
        const IV_SIZE = 12;

        function arrayToHex(arr) {
            return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
        }

        function hexToArray(hex) {
            return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
        }

        function concatArrays(arrays) {
            const totalLen = arrays.reduce((len, arr) => len + arr.length, 0);
            const result = new Uint8Array(totalLen);
            let offset = 0;
            for (let arr of arrays) {
                result.set(arr, offset);
                offset += arr.length;
            }
            return result;
        }

        async function getMlKemClass() {
            const { [MLKEM_VARIANT]: MlKemClass } = await import('https://esm.sh/mlkem');
            return MlKemClass;
        }

        async function generateKeypair() {
            try {
                const MlKemClass = await getMlKemClass();
                const instance = new MlKemClass();
                const [pk, sk] = await instance.generateKeyPair();
                document.getElementById('publicKey').innerText = 'Public Key (hex):\n' + arrayToHex(pk);
                document.getElementById('privateKey').innerText = 'Private Key (hex):\n' + arrayToHex(sk);
            } catch (error) {
                alert('Error generating keypair: ' + error.message);
            }
        }

        async function connectWallet() {
            if (!window.ethereum) return alert('MetaMask not detected');
            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send('eth_requestAccounts', []);
                const network = await provider.getNetwork();
                if (network.chainId !== 50) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x32',
                            chainName: 'XDC Network',
                            rpcUrls: ['https://rpc.ankr.com/xdc'],
                            nativeCurrency: { name: 'XDC', symbol: 'XDC', decimals: 18 },
                            blockExplorerUrls: ['https://explorer.xinfin.network']
                        }]
                    });
                }
                alert('Wallet connected');
            } catch (error) {
                alert('Error connecting wallet: ' + error.message);
            }
        }

        async function sendMessage() {
            if (!provider) return alert('Connect wallet first');
            try {
                let to = document.getElementById('toAddr').value.trim();
                if (to === '') {
                    to = '0x0000000000000000000000000000000000000000';
                } else if (to.startsWith('xdc')) {
                    to = '0x' + to.slice(3);
                }
                const pubKeyHex = document.getElementById('pubKey').value.trim();
                const pk = hexToArray(pubKeyHex);
                const msg = document.getElementById('message').value;
                const amount = document.getElementById('amount').value;

                const MlKemClass = await getMlKemClass();
                const sender = new MlKemClass();
                const [ct, ss] = await sender.encap(pk);
                const key = await crypto.subtle.importKey('raw', ss, 'AES-GCM', true, ['encrypt']);
                const iv = crypto.getRandomValues(new Uint8Array(IV_SIZE));
                const encryptedMsg = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, new TextEncoder().encode(msg));
                const fullData = concatArrays([ct, iv, new Uint8Array(encryptedMsg)]);
                const dataHex = '0x' + arrayToHex(fullData);

                const signer = provider.getSigner();
                const tx = {
                    to,
                    value: ethers.utils.parseEther(amount.toString()),
                    data: dataHex
                };
                const resp = await signer.sendTransaction(tx);
                document.getElementById('txStatus').innerText = 'Transaction Hash: ' + resp.hash + '\nWaiting for confirmation...';
                await resp.wait();
                document.getElementById('txStatus').innerText += '\nConfirmed!';
            } catch (error) {
                alert('Error sending message: ' + error.message);
            }
        }

        async function decryptMessage() {
            try {
                const txHash = document.getElementById('txHashInput').value.trim();
                const privKeyHex = document.getElementById('privKey').value.trim();
                const sk = hexToArray(privKeyHex);
                const rpc = document.getElementById('rpcDecrypt').value;

                const queryProvider = new ethers.providers.JsonRpcProvider(rpc);
                const tx = await queryProvider.getTransaction(txHash);
                if (!tx || !tx.data) throw new Error('Invalid transaction');

                const dataBytes = hexToArray(tx.data.slice(2));
                const ct = dataBytes.slice(0, CT_SIZE);
                const iv = dataBytes.slice(CT_SIZE, CT_SIZE + IV_SIZE);
                const encMsg = dataBytes.slice(CT_SIZE + IV_SIZE);

                const MlKemClass = await getMlKemClass();
                const recipient = new MlKemClass();
                const ss = await recipient.decap(ct, sk);
                const key = await crypto.subtle.importKey('raw', ss, 'AES-GCM', true, ['decrypt']);
                const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encMsg);
                const msg = new TextDecoder().decode(decrypted);

                document.getElementById('decryptedMessage').innerText = 'Decrypted Message:\n' + msg;
            } catch (error) {
                alert('Error decrypting message: ' + error.message);
            }
        }
    </script>
</body>
</html>
